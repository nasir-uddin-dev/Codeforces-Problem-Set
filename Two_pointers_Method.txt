Two Pointers Method
The Two Pointers Method is an important technique that is ofter used in competetive programming.
What is this method > The easiest way to explain it is with the example of the task "Merging two sorted arrays"

What is this task ? We are given two arrays, sorted in ascending order, a and b. We want to combine the elements of these arrays into one big array c , also sorted in ascending order.

The easiest way to do this is with the following algorithm :
1) collect all the elements into one big array;
2) sort it with any sorting built into your language.

Such an algorithm will take time 0(n.log(n))

In this step, we will learn how to do it simply, without sorting and in time faster than 0(n.log(n)) (in linear time)

Let's see an example . We are given two arrays :
        a = [1,3,5,8,10]
        b = [2,6,7,9,13]
    
How do we merge them into one sorted array ? To answer this question, let's understand which element will be in the first position in this array. Of course, this is the smallest element among all in a and b. In array a, the minimum element is the first (since the array is sorted). The situation is similar in array b.

Let's look at these two elements (the first in a and b), select the minimum one and move it to the first position in array c.

Now let's look again at the first non-deleted element of array a and the first non-deleted element of array b. They are the smallest ones remaining in their arrays. Let's choose the smaller of  these two elements and transfer it to c.


            a = [1,3,5,8,10]
            b = [2,6,7,9,13]
                c = [1,2]

We will continue this algorithm until all the elements in a and b are removed.
How to implement this ? You need to create two pointers (this where the name of the method is from)

The first pointer will point to the first non-deleted element in a, and the second pointer to the first non-deleted element in b.

        a = [1,3,5,8,10]
        b = [2,6,7,9,13]
            c = [1,2]

Each time we look , which of the elements under the pointers is smaller. If it is from the array a, then you need to transfer it. Otherwise, you need to transfer an element from array b. The index of the transfered element in array c will always be i+j. After we have moved the element, the corresponding pointer needs to be shifted to the right.

In the implementation of the algorithm, you need to be careful, at some point the elements of one of the arrays will run out completely, but in the other array the elements will still remain. For example, at the end of the algorithm with our example, we come to the following situation :

        a = [1,3,5,8,10]
        b = [2,6,7,9,13]
            c = [1,2,3,5,6,7,8,9,10]

If you do not implement the algorithm carefully, then at the next check which of the pointers is on the smallest element, you will go beyond the boundaries of the array.

There are two ways to solve this problem.

The first is to add infinity to the end of each of the arrays (in your programming language, this is the maximum number that fits into the data type).

Second solutions is to write the condition more accurately. When do you need to transfer an element from the first array ? In case the second array has ended completely or if the first array has not ended yet and the element in it is less than the element in array b. The second case is dealt with in a similar way.

Why does this work in linear time ? Each time we 